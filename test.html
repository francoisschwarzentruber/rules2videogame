<html>


<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.0/nipplejs.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
        }

        body,
        html {
            background-color: black;
            height: 100%;
        }

        canvas {
            padding: 0;
            margin: auto;
            display: block;
            height: 100%;
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            background-size: 100% 100%;
        }
    </style>
</head>

<body>
    <canvas id="canvas" width="640" height="480">
    </canvas>
    <script type="module">
        import Engine from "./engine/core.js";
        import "./engine/graphics.js";
        import "./engine/camera.js";
        import "./engine/input.js";
        import "./engine/physics.js";
        import "./engine/timer.js";
        import "./engine/scene_circleengine_logo.js";
        import "./engine/person.js";
        import "./engine/tree.js";
        import { Sound } from "./engine/sound.js";
        import { Geometry } from "./engine/physicsHelper.js";

        Engine.data.SCENE_TEST = 2;
        Engine.data.scene = {};
        Engine.data.sceneName = Engine.data.SCENE_TEST;

        Engine.addRule((G) => {
            if (G.sceneName == G.SCENE_CIRCLEENGINE_LOGO && G.keyboard.action)
                G.sceneName = G.SCENE_TEST;
        });


        Engine.addRule((G) => {
            if (G.scene.sceneName == G.SCENE_TEST)
                return;

            if (G.sceneName == G.SCENE_TEST) {

                G.link = { person: true, acceleration: true, player: true, position: { x: 300, y: 50 }, color: "green", direction: { x: 1, y: 0 } };
                // G.friend = { person: true, acceleration: true, position: { x: 300, y: 50 }, color: "blue", direction: { x: 0, y: 1 } };
                G.scene = {};
                G.scene.sceneName = G.SCENE_TEST;
                G.scene.sky = { position: { x: 300, y: 50 }, color: "darkblue", radius: 10000, disk: true };
                /*   G.scene.trees = [];
                  G.scene.trees.push({ tree: true, position: { x: 100, y: 0 } });
                  G.scene.trees.push({ tree: true, position: { x: 100, y: 200 } });
                  G.scene.trees.push({ takable: true, disk: true, position: { x: 200, y: 200 }, radius: 16, color: "yellow" });
  */

                G.scene.boss = [{ snake: true, position: { x: 0, y: 0 } },
                    //    { snake: true, position: { x: 600, y: 0 } }
                ]

                /*   for (let i = 0; i < 10; i++)
                       G.scene.trees.push({ tree: true, position: { x: 1000 * Math.random(), y: 2000 * Math.random() } });
                  */
                G.camera = {};
                G.camera.follows = G.link;
            }
        });


        Engine.addRule((G) => {
            G.camera.follows = G.link.position;
        });


        Engine.addRule((G) => {
            const X = G.link;
            if (G.keyboard.left) {
                X.acceleration.x -= 1;
                X.direction = { x: -1, y: 0 };
            }
            if (G.keyboard.right) {
                X.acceleration.x += 1;
                X.direction = { x: 1, y: 0 };
            }
            if (G.keyboard.up) {
                X.direction = { x: 0, y: -1 };
                X.acceleration.y -= 1.
            }
            if (G.keyboard.down) {
                X.acceleration.y += 1.
                X.direction = { x: 0, y: 1 };
            }
        });



        Engine.addRule((G) => {
            if (!G.keyboard.action) {
                const X = G.link;
                for (const Y of Engine.objects) {
                    if (Y.position && Y.radius && Y.takable && Y.taken) {
                        Y.taken = false;
                        Y.position.x += X.direction.x * 32;
                        Y.position.y += 32 + 16;
                        Y.solid = false;
                        Y.acceleration = false;
                    }
                }
            }
        })

        Engine.addRule((G) => {
            if (G.keyboard.action) {
                const X = G.link;
                for (const Y of Engine.objects) {
                    if (Y.position && Y.radius && Y.takable && !Y.taken)
                        if (Geometry.distance(X, Y) < X.radius + Y.radius + 4) {
                            Y.taken = true;
                            Y.z = 1;
                            Y.solid = false;
                            Y.acceleration = false;
                            return;
                        }
                }


                if (G.scene.balls == undefined)
                    G.scene.balls = [];

                if (!G.preventShooting) {
                    Sound.play("sword.ogg");
                    G.scene.balls.push({
                        ball: true,
                        velocity: { x: 10 * G.link.direction.x, y: 10 * G.link.direction.y },
                        position: { x: G.link.position.x, y: G.link.position.y }
                    });
                    G.preventShooting = { timer: 10 };
                }


            }
        });

        Engine.addRule((G) => {
            const X = G.link;
            for (const Y of Engine.objects) {
                if (Y.taken) {
                    Y.position.x = X.position.x + X.direction.x * (4);
                    Y.position.y = X.position.y - 32 + X.direction.y * (4);
                }
            }
        });






        Engine.addRule((X) => {
            if (X.ball) {
                X.disk = true;
                X.radius = 8;
                X.color = "white";
                if (X.timer == undefined)
                    X.timer = 50;
            }
        });


        Engine.addRule((X) => {
            if (X.ball && X.timer <= 0) {
                Engine.delete(X);
            }
        });


        Engine.addRule((X, G) => {
            if (X.acceleration) {
                const fact = 0.7;
                X.acceleration = { x: fact * X.acceleration.x, y: fact * X.acceleration.y };
                X.velocity = { x: fact * X.velocity.x, y: fact * X.velocity.y };
            }
        });





        Engine.addRule((X, G) => {
            if (X.snake) {
                if (!X.body) {
                    X.body = [];
                    for (let i = 1; i < 7; i++)
                        X.body.push({
                            solid: true,
                            enemy: true,
                            disk: true,
                            position: { ...X.position }, radius: 24,
                            color: "yellow"
                        });

                }

                X.body[0].radius = 32;
                X.body[X.body.length - 1].color = "red";

                X.body[0].velocity = Geometry.normalize(
                    {
                        x: G.link.position.x - X.body[0].position.x,
                        y: G.link.position.y - X.body[0].position.y
                    },
                    4);

                if (!X.eye1)
                    X.eye1 = { eye: true, position: {} };
                const v = Geometry.normalize(X.body[0].velocity, 16);
                X.eye1.position.x = X.body[0].position.x + v.x;
                X.eye1.position.y = X.body[0].position.y + v.y;
                X.eye1.direction = Geometry.normalize(X.body[0].velocity);

                for (let i = 1; i < X.body.length; i++)
                    Geometry.touches(X.body[i], X.body[i - 1]);

            }
        })



        Engine.addRule((X, G) => {
            if (X.snake) {
                for (const Y of Engine.objects) {
                    if (Y.ball) {
                        if (Geometry.intersects(Y, X.body[X.body.length - 1])) {
                            Engine.delete(Y);
                            if (X.body.length == 3) {
                                Engine.add({ explosions: true, position: X.body[0].position, size: 100, timer: 200 });
                                Engine.add({ explosions: true, position: X.body[1].position, size: 100, timer: 200 });
                                Engine.add({ explosions: true, position: X.body[2].position, size: 100, timer: 200 });
                                Engine.delete(X);
                            }
                            else {
                                Engine.add({ explosions: true, position: X.body[X.body.length - 1].position, timer: 20 });
                                Engine.delete(X.body[X.body.length - 1]);
                            }
                        }
                    }
                }
            }
        });



        Engine.addRule((X) => {
            if (X.explosions && (Math.random() < 0.15)) {
                Sound.play("explosion.ogg");
                const Y = {};
                Y.explosion = true;
                Y.position = {};
                Y.size = X.size;
                Y.position.x = X.position.x + Math.random() * 4 - 2;
                Y.position.y = X.position.y + Math.random() * 4 - 2;
                Engine.add(Y);
            }
        });


        Engine.addRule((X) => {
            if (X.explosion) {
                X.disk = true;
                X.color = "#FF000088";
                if (!X.timer)
                    X.timer = 10;
                if (!X.size)
                    X.size = 50;
                X.radius = Math.min(X.timer * X.size / 20, X.size * (1 - X.timer / 20));
            }
        });

        Engine.addRule((X, G) => {
            if (X.enemy && Geometry.intersects(X, G.link)) {
                Sound.play("hurt.ogg");
            }
        });


    </script>
</body>

</html>