<html>


<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.0/nipplejs.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
        }

        body,
        html {
            background-color: black;
            height: 100%;
        }

        canvas {
            padding: 0;
            margin: auto;
            display: block;
            height: 100%;
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            background-size: 100% 100%;
        }
    </style>
</head>

<body>
    <canvas id="canvas" width="640" height="480">
    </canvas>
    <script type="module">
        import Engine from "./engine/core.js";
        import "./engine/graphics.js";
        import "./engine/camera.js";
        import "./engine/input.js";
        import "./engine/physics.js";
        import "./engine/timer.js";
        import "./engine/scene_circleengine_logo.js";
        import "./engine/person.js";
        import "./engine/tree.js";
        import { Geometry } from "./engine/physicsHelper.js";
        Engine.data.SCENE_TEST = 2;
        Engine.data.scene = {};
        Engine.data.sceneName = Engine.data.SCENE_TEST;

        Engine.addRule((G) => {
            if (G.sceneName == G.SCENE_CIRCLEENGINE_LOGO && G.keyboard.action)
                G.sceneName = G.SCENE_TEST;
        });


        Engine.addRule((G) => {
            if (G.scene.sceneName == G.SCENE_TEST)
                return;

            if (G.sceneName == G.SCENE_TEST) {

                G.link = { person: true, acceleration: true, player: true, position: { x: 300, y: 50 }, color: "red", direction: { x: 1, y: 0 } };
                G.friend = { person: true, acceleration: true, position: { x: 300, y: 50 }, color: "blue", direction: { x: 0, y: 1 } };
                G.scene = {};
                G.scene.sceneName = G.SCENE_TEST;
                G.scene.sky = { position: { x: 300, y: 50 }, color: "lightblue", radius: 10000, disk: true };
                G.scene.trees = [];
                G.scene.trees.push({ tree: true, position: { x: 100, y: 0 } });
                G.scene.trees.push({ tree: true, position: { x: 100, y: 200 } });
                G.scene.trees.push({ takable: true, disk: true, position: { x: 200, y: 200 }, radius: 16, color: "yellow" });

                for (let i = 0; i < 10; i++)
                    G.scene.trees.push({ tree: true, position: { x: 1000 * Math.random(), y: 2000 * Math.random() } });
                G.camera = {};
                G.camera.follows = G.link;
            }
        });


        Engine.addRule((G) => {
            G.camera.follows = G.link.position;
        });


        Engine.addRule((G) => {
            const X = G.link;
            if (G.keyboard.left) {
                X.acceleration.x -= 1;
                X.direction = { x: -1, y: 0 };
            }
            if (G.keyboard.right) {
                X.acceleration.x += 1;
                X.direction = { x: 1, y: 0 };
            }
            if (G.keyboard.up) {
                X.direction = { x: 0, y: -1 };
                X.acceleration.y -= 1.
            }
            if (G.keyboard.down) {
                X.acceleration.y += 1.
                X.direction = { x: 0, y: 1 };
            }
        });



        Engine.addRule((G) => {
            if (!G.keyboard.action) {
                const X = G.link;
                for (const Y of Engine.objects) {
                    if (Y.position && Y.radius && Y.takable && Y.taken) {
                        Y.taken = false;
                        Y.position.x += X.direction.x * 32;
                        Y.position.y += 32 + 16;
                        Y.solid = false;
                        Y.acceleration = false;
                    }
                }
            }
        })

        Engine.addRule((G) => {
            if (G.keyboard.action) {
                const X = G.link;
                for (const Y of Engine.objects) {
                    if (Y.position && Y.radius && Y.takable && !Y.taken)
                        if (Geometry.distance(X, Y) < X.radius + Y.radius + 4) {
                            Y.taken = true;
                            Y.z = 1;
                            Y.solid = false;
                            Y.acceleration = false;
                        }
                }
            }
        });

        Engine.addRule((G) => {
            const X = G.link;
            for (const Y of Engine.objects) {
                if (Y.taken) {
                    Y.position.x = X.position.x + X.direction.x * (4);
                    Y.position.y = X.position.y - 32 + X.direction.y * (4);
                }
            }
        });



        Engine.addRule((X, G) => {
            if (X.acceleration) {
                const fact = 0.7;
                X.acceleration = { x: fact * X.acceleration.x, y: fact * X.acceleration.y };
                X.velocity = { x: fact * X.velocity.x, y: fact * X.velocity.y };
            }
        });


    </script>
</body>

</html>